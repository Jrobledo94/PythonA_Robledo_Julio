from typing import Any
from django.db.models.query import QuerySet
from django.shortcuts import render, get_object_or_404, redirect
from django.http import HttpResponse, HttpResponseRedirect
from django.urls import reverse
from django.db.models import F
from .models import Question, Choice
from django.views import generic
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth import authenticate, login, logout


"""
We’re using two generic views here: ListView and DetailView. Respectively, those two views abstract the concepts of “display a list of objects” 
and “display a detail page for a particular type of object.”

    Each generic view needs to know what model it will be acting upon. This is provided using the model attribute.
    The DetailView generic view expects the primary key value captured from the URL to be called "pk", so we’ve changed question_id to pk for the generic views.

By default, the DetailView generic view uses a template called <app name>/<model name>_detail.html. 
In our case, it would use the template "polls/question_detail.html". The template_name attribute is used to tell Django to use a specific template name 
instead of the autogenerated default template name. We also specify the template_name for the results list view – this 
ensures that the results view and the detail view have a different appearance when rendered, even though they’re both a DetailView behind the scenes.

Similarly, the ListView generic view uses a default template called <app name>/<model name>_list.html; 
we use template_name to tell ListView to use our existing "polls/index.html" template.

In previous parts of the tutorial, the templates have been provided with a context that contains the question and latest_question_list context variables. 
For DetailView the question variable is provided automatically – since we’re using a Django model (Question), Django is able to determine an appropriate 
name for the context variable. However, for ListView, the automatically generated context variable is question_list. 
To override this we provide the context_object_name attribute, specifying that we want to use latest_question_list instead. 
As an alternative approach, you could change your templates to match the new default context variables – but it’s a lot easier to tell Django 
to use the variable you want.
"""

class IndexView(generic.ListView):
    template_name = "polls/index.html"
    context_object_name = "latest_question_list"
    def get_queryset(self) -> QuerySet[Any]:
        return Question.objects.order_by("-pub_date")[:5]


class DetailView(generic.DetailView):
    model = Question
    template_name = "polls/detail.html"


class ResultsView(generic.DetailView):
    model = Question
    template_name = "polls/results.html"


def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        ## request.POST is a dictionary-like object that lets you access submitted data by key name. request.POST values are always strings.
        selected_choice = question.choice_set.get(pk=request.POST["choice"])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(
            request,
            "polls/detail.html",
            {
                "question": question,
                "error_message": "You didn't select a choice.",
            },
        )
    else:
        selected_choice.votes = F("votes") + 1
        selected_choice.save()
        # Always return an HttpResponseRedirect after successfully dealing
        # with POST data. This prevents data from being posted twice if a
        # user hits the Back button.
        # This tip isn’t specific to Django; it’s good web development practice in general.
        # reverse() helps avoid having to hardcode a URL in the view function. 
        # It is given the name of the view that we want to pass control to and the variable portion of the URL pattern that points to that view. In this case, using the URLconf we set up in Tutorial 3, this reverse() call will return a string like "/polls/3/results/"
        return HttpResponseRedirect(reverse("polls:results", args=(question.id,)))


def signin(request):
    if request.method == 'GET':
        return render(request, 'polls/login.html', {"form": AuthenticationForm})
    else:
        user = authenticate(
            request, username=request.POST['username'], password=request.POST['password'])
        if user is None:
            return render(request, 'polls/login.html', {"form": AuthenticationForm, "error": "Username or password is incorrect."})
        login(request, user)
        return redirect('polls:vote')